# Техническая документация API "Wallet API"

**Содержание:**

1.  [Введение](#введение)
2.  [Архитектура приложения](#архитектура-приложения)
3.  [Описание API Endpoints](#описание-api-endpoints)
    *   [POST /api/register/ (User Registration)](#post-apiregister-user-registration)
    *   [GET /api/wallets/{WALLET_UUID}/ (Wallet Detail)](#get-apiwalletswallet_uuid-wallet-detail)
    *   [POST /api/wallets/{WALLET_UUID}/operation/ (Wallet Operation)](#post-apiwalletswallet_uuidoperation-wallet-operation)
4.  [Модели данных](#модели-данных)
    *   [UserRegistrationSerializer](#userregistrationserializer)
    *   [WalletSerializer](#walletserializer)
    *   [WalletOperationSerializer](#walletoperationserializer)

---

## 1. Введение

**Краткое описание приложения:**

Данное приложение представляет собой RESTful API, предназначенный для управления электронными кошельками. Приложение предоставляет набор endpoints для выполнения основных операций с кошельками, таких как:

*   **Регистрация новых пользователей** и автоматическое создание персонального кошелька при регистрации.
*   **Пополнение баланса кошелька (DEPOSIT).**
*   **Снятие средств с кошелька (WITHDRAW).**
*   **Получение текущего баланса кошелька.**

---

## 2. Архитектура приложения

*   **Общая схема архитектуры:**

    > Приложение "Wallet API" имеет трехуровневую архитектуру, основанную на следующих основных компонентах:

    *   **Django REST Framework (Backend API):**
        > Является основным фреймворком бэкенда, отвечающим за создание и управление RESTful API endpoints. Django REST Framework обеспечивает:
        >
        > *   **Обработку HTTP запросов** к API endpoints (`/api/wallets/.../operation/`, `/api/wallets/{WALLET_UUID}/`, `/api/register/`).
        > *   **Маршрутизацию запросов** к соответствующим вьюхам (`WalletOperation`, `WalletDetail`, `UserRegistration`).
        > *   **Сериализацию и десериализацию данных** (преобразование JSON данных запросов в Python объекты и обратно в JSON ответы) с использованием сериализаторов (`WalletOperationSerializer`, `WalletSerializer`, `UserRegistrationSerializer`).
        > *   **Валидацию входных данных** с помощью сериализаторов для обеспечения корректности запросов API.
        > *   **Генерацию HTTP ответов** в формате JSON с соответствующими статус кодами (200 OK, 400 Bad Request, 404 Not Found, 500 Internal Server Error).
        > *   **Интеграцию с базой данных PostgreSQL** через Django ORM для доступа к данным кошельков и пользователей.
        > *   **Логирование ошибок** и исключений с использованием Python logging.
        > *   **Покрытие API endpoints тестами** (юнит-тесты Django) для обеспечения корректности работы и предотвращения регрессий.

    *   **PostgreSQL (Database):**
        > Выступает в качестве основной системы управления базами данных (СУБД) для приложения. PostgreSQL используется для:
        >
        > *   **Хранения данных о пользователях** (модель `User` Django).
        > *   **Хранения данных о кошельках** (модель `Wallet`).
        > *   **Обеспечения *персистентности* данных** - данные сохраняются на диске и не теряются после перезапуска приложения.
        > *   **Поддержки *транзакций ACID* для обеспечения целостности данных** при выполнении операций с кошельками (DEPOSIT, WITHDRAW).
        > *   **Атомарного обновления баланса кошелька** с использованием механизма `F-выражений Django ORM` для предотвращения race conditions и обеспечения *конкурентного доступа* к данным кошельков при высокой нагрузке.
        > *   **Индексирования таблиц базы данных** (модель `Wallet.Meta.indexes`) для *оптимизации производительности запросов* к базе данных.
        > *   **Управления схемой базы данных с помощью Django migrations.**

    *   **Gunicorn (WSGI Server):**
        > Используется как production-ready WSGI HTTP-сервер для запуска Django приложения. Gunicorn обеспечивает:
        >
        > *   **Прием HTTP запросов** от Nginx reverse proxy.
        > *   **Передачу запросов Django приложению** для обработки.
        > *   **Управление *воркерами* (worker processes) для *параллельной обработки запросов*.**  В приложении используются `gevent` воркеры для повышения производительности I/O-bound операций.
        > *   **Логирование работы сервера** (уровень логирования `debug` для отладки, `info`, `notice`, `error` для production).
        > *   **Перезапуск приложения** при изменениях в коде.

    *   **Nginx (Reverse Proxy & Static Files Server):**
        > Выполняет роль reverse proxy и сервера статических файлов перед Gunicorn и Django приложением. Nginx обеспечивает:
        >
        > *   **Прием входящих HTTP запросов от клиентов** (Postman, браузер).
        > *   **Проксирование API запросов** (`/api/wallets/.../operation/`, `/api/wallets/{WALLET_UUID}/`, `/api/register/`) к бэкенд серверу Gunicorn (на порт 8000).
        > *   **Раздачу статических файлов Django Admin панели** (CSS, JavaScript, изображения) из директории `/app/staticfiles/` (смонтированного Docker volume `static_volume`).  Настроено раздачу статики из блока `location /static/` в `nginx.conf`.
        > *   **Логирование запросов и ошибок Nginx.**
        > *   **Слушает на порту 8080** и проксирует запросы к Gunicorn на порт 8000.

    *   **Docker Compose (Containerization):**
        > Используется для *контейнеризации* приложения и всех его зависимостей (Django, PostgreSQL, Nginx). Docker Compose позволяет:
        >
        > *   **Упаковать приложение и все его зависимости в *изолированные Docker контейнеры*.**
        > *   **Обеспечить *воспроизводимость окружения* разработки, тестирования и production.**  Приложение запускается *одинаково* на любой системе, где установлен Docker.
        > *   **Управлять *запуском и остановкой всех компонентов приложения* (Django, PostgreSQL, Nginx) *одной командой* (`docker-compose up`, `docker-compose down`).**
        > *   **Настраивать *связи между контейнерами* (сети Docker Compose, `depends_on`) для обеспечения взаимодействия между компонентами приложения.**
        > *   **Монтировать *volumes* (`static_volume`, `postgres_data`) для хранения данных статики и базы данных *вне контейнеров*, чтобы данные сохранялись после перезапуска контейнеров.**
        > *   **Простое *развертывание* приложения на любой платформе, поддерживающей Docker.**

*   **Диаграмма архитектуры:**

    ```
    [Клиент (Postman, Браузер)]  <--->  [Nginx (порт 8080)]  <--->  [Gunicorn (порт 8000) + Django App]  <--->  [PostgreSQL Database]
                                        |
                                        └──> [Статические файлы]
    ```

---

## 3. Описание API Endpoints

*   **`POST /api/register/` (User Registration):**

    *   **URL:** `/api/register/`
    *   **HTTP метод:** `POST`
    *   **Описание:** Регистрация нового пользователя и создание для него кошелька.

    *   **Тело запроса (Request Body):**  `application/json`

        > Тело запроса должно быть в формате JSON и содержать следующие поля:
        >
        > *   **`username` (string, required):**  Имя пользователя. Должно быть *уникальным*.  *Пример*: `"john_doe"`.
        > *   **`email` (string, email, required):**  Email адрес пользователя.  Должен быть в *формате email*.  Должен быть *уникальным*. *Пример*: `"john.doe@example.com"`.
        > *   **`password` (string, required, writeOnly: true):**  Пароль пользователя.  *Пример*: `"P@$$wOrd123"`.
        >
        > **Пример валидного JSON тела запроса:**
        >
        > ```json
        > {
        >     "username": "new_user",
        >     "email": "new_user@example.com",
        >     "password": "StrongPassword123"
        > }
        > ```

    *   **Параметры URL (URL Parameters):**  Нет.

    *   **Заголовки запроса (Request Headers):**  `Content-Type: application/json`

    *   **Успешный ответ (201 Created):**  `201 Created`

        > Успешный ответ возвращается со статус кодом `201 Created` и JSON телом, содержащим информацию о созданном пользователе и кошельке:
        >
        > *   **`username` (string):**  Имя пользователя.  *Пример*: `"new_user"`.
        > *   **`email` (string, email):**  Email адрес пользователя.  *Пример*: `"new_user@example.com"`.
        > *   **`wallet_balance` (string, decimal):**  Баланс созданного кошелька (всегда `"0.00"` при регистрации).  *Пример*: `"0.00"`.
        >
        > **Пример успешного JSON тела ответа:**
        >
        > ```json
        > {
        >     "username": "new_user",
        >     "email": "new_user@example.com",
        >     "wallet_balance": "0.00"
        > }
        > ```

    *   **Возможные ошибки (400 Bad Request):**  `400 Bad Request`

        > Ошибка `400 Bad Request` возвращается в случае *ошибок валидации входных данных*.  JSON тело ответа содержит *словарь ошибок валидации*, где ключи - это *названия полей*, а значения - *списки сообщений об ошибках* для каждого поля.
        >
        > **Пример JSON тела ответа с ошибками валидации (неверный формат email и имя пользователя уже занято):**
        >
        > ```json
        > {
        >     "email": [
        >         "Enter a valid email address."
        >     ],
        >     "username": [
        >         "Такое имя пользователя уже зарегистрировано."
        >     ]
        > }
        > ```

*   **`GET /api/wallets/{WALLET_UUID}/` (Wallet Detail):**

    *   **URL:** `/api/wallets/{WALLET_UUID}/`
    *   **HTTP метод:** `GET`
    *   **Описание:** Получение информации о кошельке по его UUID.

    *   **Тело запроса (Request Body):**  Нет.

    *   **Параметры URL (URL Parameters):**
        *   **`WALLET_UUID` (string, UUID, path, required):**  UUID кошелька, информацию о котором нужно получить.  Должен быть в *формате UUID*.  *Пример*: `"47c6a995-7685-412c-99fe-4259db91f18f"`.

    *   **Успешный ответ (200 OK):**  `200 OK`

        > Успешный ответ возвращается со статус кодом `200 OK` и JSON телом, содержащим детали кошелька:
        >
        > *   **`user` (integer, readOnly: true):**  ID пользователя - владельца кошелька (primary key модели `User`).  *Пример*: `123`.
        > *   **`balance` (string, decimal, readOnly: true):**  Текущий баланс кошелька.  *Пример*: `"1200.50"`.
        >
        > **Пример успешного JSON тела ответа:**
        >
        > ```json
        > {
        >     "user": 1,
        >     "balance": "1200.50"
        > }
        > ```

    *   **Возможные ошибки (404 Not Found):**  `404 Not Found`

        > Ошибка `404 Not Found` возвращается, если кошелек с указанным `WALLET_UUID` не найден в базе данных.  JSON тело ответа содержит сообщение об ошибке:
        >
        > *   **`detail` (string):** Сообщение об ошибке "Кошелек не найден.".
        >
        > **Пример JSON тела ответа с ошибкой 404 Not Found:**
        >
        > ```json
        > {
        >     "detail": "Кошелек не найден."
        > }
        > ```

*   **`POST /api/wallets/{WALLET_UUID}/operation/` (Wallet Operation):**

    *   **URL:** `/api/wallets/{WALLET_UUID}/operation/`
    *   **HTTP метод:** `POST`
    *   **Описание:** Выполнение операции пополнения (DEPOSIT) или снятия (WITHDRAW) средств с кошелька.

    *   **Тело запроса (Request Body):**  `application/json`

        > Тело запроса должно быть в формате JSON и содержать следующие поля:
        >
        > *   **`operationType` (string, enum, required):**  Тип операции.  Допустимые значения: `"DEPOSIT"` (пополнение) или `"WITHDRAW"` (снятие).  *Пример*: `"DEPOSIT"`.
        > *   **`amount` (string, decimal, required):**  Сумма операции.  Должна быть *положительным десятичным числом* с точностью до *двух знаков после запятой*.  *Пример*: `"100.00"`.
        >
        > **Примеры валидных JSON тел запроса:**
        >
        > **Для операции DEPOSIT (пополнение):**
        >
        > ```json
        > {
        >     "operationType": "DEPOSIT",
        >     "amount": "100.00"
        > }
        > ```
        >
        > **Для операции WITHDRAW (снятие):**
        >
        > ```json
        > {
        >     "operationType": "WITHDRAW",
        >     "amount": "50.00"
        > }
        > ```

    *   **Параметры URL (URL Parameters):**
        *   **`WALLET_UUID` (string, UUID, path, required):**  UUID кошелька, над которым выполняется операция.  Должен быть в *формате UUID*.  *Пример*: `"47c6a995-7685-412c-99fe-4259db91f18f"`.

    *   **Заголовки запроса (Request Headers):**  `Content-Type: application/json`

    *   **Успешный ответ (200 OK):**  `200 OK`

        > Успешный ответ возвращается со статус кодом `200 OK` и JSON телом, содержащим результат операции:
        >
        > *   **`status` (string):**  Статус операции (всегда `"success"` для успешных операций).  *Пример*: `"success"`.
        > *   **`balance` (string, decimal):**  Текущий баланс кошелька после выполнения операции.  *Пример*: `"1200.50"`.
        >
        > **Пример успешного JSON тела ответа:**
        >
        > ```json
        > {
        >     "status": "success",
        >     "balance": "1200.50"
        > }
        > ```

    *   **Возможные ошибки (400 Bad Request):**  `400 Bad Request`

        > Ошибка `400 Bad Request` может быть возвращена в следующих случаях:
        >
        > *   **Validation Errors (Ошибки валидации):**  Если *данные запроса не соответствуют требованиям сериализатора* (неверный формат JSON, неверные типы данных, отсутствуют обязательные поля, неверные значения полей).  JSON тело ответа содержит словарь ошибок валидации, где ключи - это названия полей, а значения - списки сообщений об ошибках для каждого поля.
        >
        >     **Пример JSON тела ответа с ошибками валидации (неверный формат `amount` и неверный `operationType`):**
        >
        >     ```json
        >     {
        >         "amount": [
        >             "A valid number is required."
        >         ],
        >         "operationType": [
        >             "\"INVALID_OPERATION_TYPE\" is not a valid choice."
        >         ]
        >     }
        >     ```
        >
        > *   **Insufficient Funds (Недостаточно средств):**  Если для операции `WITHDRAW` на кошельке недостаточно средств для снятия указанной суммы.  JSON тело ответа содержит сообщение об ошибке:
        >
        >     *   **`status` (string):**  Статус ошибки (всегда `"error"` для ошибок).  *Пример*: `"error"`.
        >     *   **`message` (string):**  Сообщение об ошибке "Недостаточно средств".  *Пример*: `"Недостаточно средств"`.
        >
        >     **Пример JSON тела ответа с ошибкой "Недостаточно средств":**
        >
        >     ```json
        >     {
        >         "status": "error",
        >         "message": "Недостаточно средств"
        >     }
        > ```
        >
        > *   **Invalid Operation Type (Неверный тип операции):**  Если в поле `operationType` указано недопустимое значение (не `"DEPOSIT"` и не `"WITHDRAW"`).  JSON тело ответа содержит сообщение об ошибке:
        >
        >     *   **`status` (string):**  Статус ошибки (всегда `"error"` для ошибок).  *Пример*: `"error"`.
        >     *   **`message` (string):**  Сообщение об ошибке "Неизвестный тип операции".  *Пример*: `"Неизвестный тип операции"`.
        >
        >     **Пример JSON тела ответа с ошибкой "Неизвестный тип операции":**
        >
        >     ```json
        >     {
        >         "status": "error",
        >         "message": "Неизвестный тип операции"
        >     }
        > ```

    *   **Возможные ошибки (404 Not Found):**  `404 Not Found`

        > Ошибка `404 Not Found` возвращается, если кошелек с указанным `WALLET_UUID` не найден в базе данных.  JSON тело ответа содержит сообщение об ошибке:
        >
        > *   **`detail` (string):** Сообщение об ошибке "Кошелек не найден.".
        >
        > **Пример JSON тела ответа с ошибкой 404 Not Found:**
        >
        > ```json
        > {
        >     "detail": "Кошелек не найден."
        > }
        > ```

    *   **Возможные ошибки (500 Internal Server Error):**  `500 Internal Server Error`

        > Ошибка `500 Internal Server Error` может быть возвращена в случае непредвиденных ошибок на сервере при обработке операции кошелька (например, ошибки базы данных, ошибки Redis, и т.д.).  JSON тело ответа содержит общее сообщение об ошибке:
        >
        > *   **`detail` (string):** Сообщение об ошибке "Ошибка при обработке операции кошелька".
        >
        > **Пример JSON тела ответа с ошибкой 500 Internal Server Error:**
        >
        > ```json
        > {
        >     "detail": "Ошибка при обработке операции кошелька"
        > }
        > ```

---

## 4. Модели данных

*   **`UserRegistrationSerializer`:**

    > **Название сериализатора:** `UserRegistrationSerializer`
    >
    > **Описание сериализатора:**  Используется для валидации и сериализации данных при регистрации новых пользователей.
    >
    > **Поля сериализатора:**
    >
    > *   **`username` (string, required):**
        > Имя пользователя.  **Тип данных:** Строка (string).  **Обязательное поле (required).**
        >
        > *   Должно быть *уникальным* - не должно совпадать с именами уже зарегистрированных пользователей в системе.
        > *   **Тип поля в Django REST Framework:** `serializers.CharField()`.
        > *   **Пример значения:** `"john_doe"`.

    > *   **`email` (string, email, required, unique):**
        > Email адрес пользователя.  **Тип данных:** Строка (string), формат Email.  **Обязательное поле (required).**  **Должно быть уникальным.**
        >
        > *   Должен соответствовать *формату email адреса* (например, содержать символ `@` и домен).
        > *   Должен быть *уникальным* - не должно совпадать с email адресами уже зарегистрированных пользователей в системе.
        > *   **Тип поля в Django REST Framework:** `serializers.EmailField()`.
        > *   **Пример значения:** `"john.doe@example.com"`.

    > *   **`password` (string, required, writeOnly: true):**
        > Пароль пользователя.  **Тип данных:** Строка (string).  **Обязательное поле (required).**  **Только для записи (writeOnly: true).**
        >
        > *   Используется для задания пароля при регистрации нового пользователя.
        > *   **Поле *только для записи (writeOnly: true)* - значение пароля *не возвращается* в ответах API** (в целях безопасности).
        > *   **Тип поля в Django REST Framework:** `serializers.CharField(write_only=True)`.
        > *   **Пример значения:** `"P@$$wOrd123"`.

    > *   **`wallet_balance` (string, decimal, readOnly: true):**
        > Баланс кошелька пользователя.  **Тип данных:** Строка (string), десятичное число (decimal).  **Только для чтения (readOnly: true).**
        >
        > *   Отображает *текущий баланс кошелька*, связанного с пользователем.
        > *   Хранится в базе данных как `DecimalField` с максимальной точностью `max_digits=12` и `decimal_places=2`.
        > *   **Поле *только для чтения (readOnly: true)* - значение баланса *нельзя изменить* напрямую через API при регистрации пользователя.**  Баланс устанавливается в `"0.00"` автоматически при создании кошелька.  Для изменения баланса используются *операции пополнения и снятия средств* (API endpoint `POST /api/wallets/{WALLET_UUID}/operation/`).
        > *   **Тип поля в Django REST Framework:** `serializers.DecimalField(source='wallet.balance', max_digits=10, decimal_places=2, read_only=True)`.
        > *   **Пример значения:** `"0.00"`.

*   **`WalletSerializer`:**

    > **Название сериализатора:** `WalletSerializer`
    >
    > **Описание сериализатора:**  Используется для сериализации данных модели `Wallet` при получении детальной информации о кошельке (API endpoint `GET /api/wallets/{WALLET_UUID}/`).
    >
    > **Поля сериализатора:**
    >
    > *   **`user` (integer, readOnly: true):**
        > ID пользователя - владельца кошелька.  **Тип данных:** Целое число (integer).  **Только для чтения (readOnly: true).**
        >
        > *   Представляет собой *внешний ключ* (ForeignKey) к модели `User`, указывающий на пользователя, которому принадлежит кошелек.
        > *   Значение поля автоматически генерируется Django ORM при создании кошелька на основе связи `OneToOneField` с моделью `User`.
        > *   **Тип поля в Django REST Framework:** `serializers.ModelSerializer` (унаследовано от модели `Wallet`).
        > *   **Пример значения:** `123`.

    > *   **`balance` (string, decimal, readOnly: true):**
        > Текущий баланс кошелька.  **Тип данных:** Строка (string), десятичное число (decimal).  **Только для чтения (readOnly: true).**
        >
        > *   Отображает *текущий баланс кошелька*.
        > *   Хранится в базе данных как `DecimalField` с максимальной точностью `max_digits=12` и `decimal_places=2`.
        > *   **Поле только для чтения (readOnly: true) - значение баланса *изменяется только* в результате выполнения операций пополнения и снятия средств** (API endpoint `POST /api/wallets/{WALLET_UUID}/operation/`).
        > *   **Тип поля в Django REST Framework:** `serializers.ModelSerializer` (унаследовано от модели `Wallet`).
        > *   **Пример значения:** `"1200.50"`.

*   **`WalletOperationSerializer`:**

    > **Название сериализатора:** `WalletOperationSerializer`
    >
    > **Описание сериализатора:**  Используется для валидации данных запроса к API endpoint `POST /api/wallets/{WALLET_UUID}/operation/` при выполнении операций пополнения (DEPOSIT) и снятия (WITHDRAW) средств с кошелька.
    >
    > **Поля сериализатора:**
    >
    > *   **`operationType` (string, enum, required):**
        > Тип операции.  **Тип данных:** Строка (string), перечисление (enum).  **Обязательное поле (required).**
        >
        > *   Указывает *тип операции*, которую нужно выполнить с кошельком.
        > *   **Допустимые значения (enum):** `"DEPOSIT"` (пополнение) или `"WITHDRAW"` (снятие).
        > *   **Тип поля в Django REST Framework:** `serializers.ChoiceField(choices=['DEPOSIT', 'WITHDRAW']).`
        > *   **Пример значения:** `"DEPOSIT"`.

    > *   **`amount` (string, decimal, required, min_value=0):**
        > Сумма операции.  **Тип данных:** Строка (string), десятичное число (decimal).  **Обязательное поле (required).**  **Минимальное значение: 0.**
        >
        > *   Указывает сумму средств для пополнения или снятия с кошелька.
        > *   Должна быть *положительным десятичным числом* (больше нуля).
        > *   Должна быть в *формате десятичного числа* с точностью до *двух знаков после запятой*.
        > *   **Валидация:**  Сериализатор содержит *явную валидацию* в методе `validate_amount(self, value)`, которая проверяет, что значение `amount` больше нуля.
        > *   **Тип поля в Django REST Framework:** `serializers.DecimalField(max_digits=10, decimal_places=2)`.
        > *   **Пример значения:** `"100.00"`.

---